## Redis

### 什么是 Redis？

Redis 是速度非常快的非关系型（NoSQL）**内存**键值数据库，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。

### Redis 与 Memcache 的区别与比较

|  | Redis | Memcache |
| ---- | ---- | ---- |
| 数据类型 | 不仅支持简单的 k-v ，同时还提供 list/set/zset/hash 等数据结构存储 | 仅支持 k-v |
| 数据持久化 | 可以将数据保持在硬盘中，重启的时候再次加载进行使用。支持两种持久化策略：RDB 快照和 AOF 日志 | 不支持 | 
| 分布式 | 支持 | 不支持 |
| 网络 I/O 模型 | 单线程 I/O 复用 | 多线程、非阻塞 I/O 复用 |
| 内存管理机制 | 并不是所有数据一直存储在内存中，可以将一些很久没有用的 value 交换到磁盘 | 数据一直存储在内存中 |
| 分配特定长度内存块存储数据 | 否 | 是（以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高） |
| master-slave 模式数据备份 | 支持 | 不支持 （无法进行同步，不能将数据迁移到其他 MC 实例中）|

### Redis 的过期删除策略是怎样的？

1. 惰性删除（冷数据占用大量内存）：读/写一个已经过期的 key，如果过期则删除
2. 定时过期（占用大量 CPU 处理过期数据）：每个设置过期时间的 key 都需要创建一个**定时器**。到了过期时间就会立即清除
3. 定期过期：每隔一段时间扫面一定数量的 key

### Redis 的数据（内存）淘汰策略是什么？

共有 6 种淘汰策略：

| 策略 |	描述 |
| ---- | ---- |
| volatile-lru | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl | 从已设置过期时间的数据集中挑选将要过期的数据淘汰 |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰 |
| allkeys-lru | 从所有数据集中挑选最近最少使用的数据淘汰 |
| allkeys-random | 从所有数据集中任意选择数据进行淘汰 |
| noeviction | 禁止驱逐数据 |

总结：最近最少使用、将要过期、随机

### SCAN 的作用？

是基于游标的迭代器（cursor based iterator）。

每次调用都会返回给用户一个新游标（下次迭代需要带上），游标等于 0 时表示迭代结束。

特点：

- 增量循环，每次调用只会返回一小部分元素
- 与 keys 不同，不会造成阻塞（Redis 是单线程的）

